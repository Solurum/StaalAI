name: StaalAI-Execute

on:
  issue_comment:
    types: [created]

permissions:
  contents: write
  pull-requests: write

jobs:
  run-staalai:
    if: >
      github.event.issue.pull_request != null &&
      contains(github.event.comment.body, 'StaalAI: Execute')
    runs-on: ubuntu-latest

    env:
      RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

    steps:
      - name: Require label "StaalAI" and commenter permission >= write
        id: authz
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const issue_number = context.payload.issue.number;
            const commenter = context.payload.comment.user.login;

            const { data: perm } = await github.rest.repos.getCollaboratorPermissionLevel({ owner, repo, username: commenter });
            const hasWriteOrAbove = ['write','maintain','admin'].includes(perm.permission);

            const labels = await github.paginate(github.rest.issues.listLabelsOnIssue, { owner, repo, issue_number, per_page: 100 });
            const hasLabel = labels.some(l => l.name.toLowerCase() === 'staalai');

            core.setOutput('hasWriteOrAbove', String(hasWriteOrAbove));
            core.setOutput('hasLabel', String(hasLabel));
            core.setOutput('ok', String(hasWriteOrAbove && hasLabel));

      - name: Stop if not authorized / not labeled
        if: steps.authz.outputs.ok != 'true'
        run: |
          MSG="Blocked: requires PR label 'StaalAI' AND commenter with write+ permissions."
          echo "$MSG" >&2
          {
            echo "AUTH_ERROR<<EOF"
            echo "$MSG"
            echo "EOF"
          } >> "$GITHUB_ENV"
          exit 1

      - name: Set up GitHub CLI
        run: gh --version

      - name: Derive PR metadata
        id: prmeta
        env:
          GH_TOKEN: ${{ secrets.PAT }}
        run: |
          PR_NUMBER="${{ github.event.issue.number }}"
          HEAD_REF=$(gh pr view "$PR_NUMBER" --repo "${{ github.repository }}" --json headRefName --jq .headRefName)
          PR_TITLE=$(gh pr view "$PR_NUMBER" --repo "${{ github.repository }}" --json title --jq .title)

          echo "pr_number=$PR_NUMBER" >> "$GITHUB_OUTPUT"
          echo "head_ref=$HEAD_REF"   >> "$GITHUB_OUTPUT"
          echo "pr_title<<EOF"        >> "$GITHUB_OUTPUT"
          echo "$PR_TITLE"            >> "$GITHUB_OUTPUT"
          echo "EOF"                  >> "$GITHUB_OUTPUT"

      - name: Check out PR head branch
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.prmeta.outputs.head_ref }}
          fetch-depth: 0
          token: ${{ secrets.PAT }}

      - name: Configure Git user
        run: |
          git config user.name "${{ github.actor }}"
          git config user.email "${{ github.actor }}@users.noreply.github.com"

      - name: Install .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Install Solurum.StaalAI dotnet tool (global)
        run: |
          dotnet tool install Solurum.StaalAI --global
          echo "$HOME/.dotnet/tools" >> $GITHUB_PATH

      - name: Collect open review remarks (unresolved review threads)
        id: collect_review_remarks
        env:
          GH_TOKEN: ${{ secrets.PAT }}
        run: |
          set -euo pipefail
          OWNER="${GITHUB_REPOSITORY%/*}"
          REPO="${GITHUB_REPOSITORY#*/}"
          PR_NUMBER="${{ github.event.issue.number }}"

          # Build GraphQL query to fetch review threads
          read -r -d '' QUERY << 'GRAPHQL' || true
          query($owner:String!, $repo:String!, $pr:Int!) {
            repository(owner:$owner, name:$repo) {
              pullRequest(number:$pr) {
                reviewThreads(first: 100) {
                  nodes {
                    isResolved
                    path
                    comments(first: 100) {
                      nodes {
                        author { login }
                        body
                        url
                        createdAt
                      }
                    }
                  }
                }
              }
            }
          }
          GRAPHQL

          RESP=$(gh api graphql -f owner="$OWNER" -f repo="$REPO" -F pr="$PR_NUMBER" -f query="$QUERY")

          mkdir -p "$GITHUB_WORKSPACE/.github"
          REMARKS_FILE="$GITHUB_WORKSPACE/.github/_open_review_remarks.txt"
          : > "$REMARKS_FILE"

          COUNT=$(echo "$RESP" | jq '[.data.repository.pullRequest.reviewThreads.nodes[] | select(.isResolved==false)] | length')
          if [ "$COUNT" -gt 0 ]; then
            echo "$RESP" | jq -r '
              .data.repository.pullRequest.reviewThreads.nodes
              | map(select(.isResolved==false))
              | .[]
              | "File: \(.path)\n"
                + (
                    .comments.nodes
                    | map(" - [\(.author.login)] \(.url)\n   \(.body|gsub("\r";"") )")
                    | join("\n")
                  )
                + "\n"
            ' >> "$REMARKS_FILE"
            echo "has_open_remarks=true" >> "$GITHUB_OUTPUT"
            echo "remarks_file=$REMARKS_FILE" >> "$GITHUB_OUTPUT"
          else
            echo "has_open_remarks=false" >> "$GITHUB_OUTPUT"
            echo "remarks_file=" >> "$GITHUB_OUTPUT"
          fi

      - name: Prepare lastprompt with open review remarks
        if: steps.collect_review_remarks.outputs.has_open_remarks == 'true'
        run: |
          set -euo pipefail
          ORIGINAL="$GITHUB_WORKSPACE/lastprompt.txt"
          BACKUP="$GITHUB_WORKSPACE/lastprompt_bak.txt"
          REMARKS_FILE="${{ steps.collect_review_remarks.outputs.remarks_file }}"

          if [ ! -f "$ORIGINAL" ]; then
            echo "lastprompt.txt not found at $ORIGINAL" >&2
            exit 1
          fi

          cp "$ORIGINAL" "$BACKUP"
          {
            echo "NOTE: Prompt was already executed and there are open review remarks to tackle."
            echo
            cat "$BACKUP"
            echo
            echo "-----"
            echo "Open Review Remarks:"
            echo
            cat "$REMARKS_FILE"
          } > "$ORIGINAL"

      - name: Run StaalAI generate
        env:
          StaalOpenApiToken: ${{ secrets.OPENAPITOKEN }}
          StaalOpenApiModel: ${{ vars.OPENAPIMODEL }}
        run: |
          StaalAI generate \
            -pf "$GITHUB_WORKSPACE/lastprompt.txt" \
            -wd "$GITHUB_WORKSPACE" \
            --debug

      - name: Restore original lastprompt before commit
        run: |
          set -euo pipefail
          ORIGINAL="$GITHUB_WORKSPACE/lastprompt.txt"
          BACKUP="$GITHUB_WORKSPACE/lastprompt_bak.txt"
          if [ -f "$BACKUP" ]; then
            rm -f "$ORIGINAL"
            mv "$BACKUP" "$ORIGINAL"
            echo "Restored original lastprompt.txt"
          else
            echo "No backup found; nothing to restore."
          fi

      - name: Commit and push changes (if any)
        id: commit
        env:
          PR_TITLE: ${{ steps.prmeta.outputs.pr_title }}
        run: |
          git add -A
          if git diff --cached --quiet; then
            echo "no_changes=true" >> "$GITHUB_OUTPUT"
            echo "No changes to commit."
          else
            COMMIT_MSG="StaalAI Suggests Code Changes for PR ${PR_TITLE}"
            git commit -m "$COMMIT_MSG"
            CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
            git push origin "$CURRENT_BRANCH"
            echo "no_changes=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Post PR comment with run result
        if: always()
        env:
          GH_TOKEN: ${{ secrets.PAT }}
          JOB_STATUS: ${{ job.status }}
        run: |
          PR_NUMBER="${{ github.event.issue.number }}"

          if [ "${{ steps.commit.outputs.no_changes }}" = "true" ]; then
            CHANGE_LINE="No changes were generated."
          else
            CHANGE_LINE="StaalAI pushed code changes."
          fi

          if [ "$JOB_STATUS" = "success" ]; then
            STATUS_LINE="✅ Pipeline **succeeded**."
          elif [ "$JOB_STATUS" = "cancelled" ]; then
            STATUS_LINE="⏹️ Pipeline **was cancelled**."
          else
            STATUS_LINE="❌ Pipeline **failed**."
          fi

          EXTRA=""
          if [ -n "${AUTH_ERROR}" ]; then
            EXTRA="\n\n**Error:** ${AUTH_ERROR}"
          fi

          COMMENT_BODY="$STATUS_LINE$EXTRA\n\n$CHANGE_LINE\n\nView logs: $RUN_URL"
          gh pr comment "$PR_NUMBER" --repo "${{ github.repository }}" --body "$COMMENT_BODY"